import React, { useRef, useState, useEffect } from "react";

export default function App() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const detectionCanvasRef = useRef(null);
  const [serial, setSerial] = useState("");
  const [side, setSide] = useState("back");
  const [validationMode, setValidationMode] = useState(false);
  const [referenceImages, setReferenceImages] = useState({});
  const [captureMode, setCaptureMode] = useState(false);
  const [validationResult, setValidationResult] = useState(null);
  const [showOverlay, setShowOverlay] = useState(false);
  const [message, setMessage] = useState("");
  const [validationStatus, setValidationStatus] = useState(null);
  const [padPositions, setPadPositions] = useState([]);
  const [validationInProgress, setValidationInProgress] = useState(false);
  const validationIntervalRef = useRef(null);

  // Color detection parameters - adjusted for better magenta detection
  const colorThreshold = {
    // Magenta detection parameters (HSV color space)
    hueMin: 260,
    hueMax: 340,
    satMin: 30,
    valMin: 40
  };

  useEffect(() => {
    // Load saved reference images from localStorage on component mount
    const savedImages = localStorage.getItem('gapPadReferenceImages');
    if (savedImages) {
      try {
        const parsed = JSON.parse(savedImages);
        setReferenceImages(parsed);
      } catch (e) {
        console.error("Failed to parse saved images", e);
        setMessage("Error loading saved images");
      }
    }
  }, []);

  useEffect(() => {
    (async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }, 
          audio: false 
        });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          await videoRef.current.play();
        }
      } catch (err) {
        console.error("Camera error", err);
        setMessage("Camera access error. Please check permissions.");
      }
    })();

    // Cleanup function for validation interval
    return () => {
      if (validationIntervalRef.current) {
        clearInterval(validationIntervalRef.current);
      }
    };
  }, []);

  // Check if a color is within the magenta range
  const isMagenta = (r, g, b) => {
    // Convert RGB to HSV
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    
    let hue;
    if (delta === 0) {
      hue = 0;
    } else if (max === r) {
      hue = ((g - b) / delta) % 6;
    } else if (max === g) {
      hue = (b - r) / delta + 2;
    } else {
      hue = (r - g) / delta + 4;
    }
    
    hue = Math.round(hue * 60);
    if (hue < 0) hue += 360;
    
    const saturation = max === 0 ? 0 : Math.round((delta / max) * 100);
    const value = Math.round((max / 255) * 100);
    
    // Debug logs to understand color detection
    console.log(`RGB: ${r},${g},${b} -> HSV: ${hue},${saturation},${value}`);
    
    // Check if the color is in the magenta range
    // For pinkish-magenta thermal pads
    return (
      (hue >= colorThreshold.hueMin && hue <= colorThreshold.hueMax) &&
      saturation >= colorThreshold.satMin && 
      value >= colorThreshold.valMin &&
      // Extra check for magenta: red high, green low, blue medium-high
      r > 150 && g < 100 && b > 100
    );
  };

  // Detect gap pads in an image
  const detectGapPads = (imageData, key) => {
    return new Promise((resolve) => {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      
      const img = new Image();
      
      img.onload = () => {
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        tempCtx.drawImage(img, 0, 0);
        
        const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imgData.data;
        
        // Array to store detected gap pad positions
        const positions = [];
        
        // Simplified detection algorithm - looks for clusters of magenta pixels
        const visited = new Set();
        const clusterMinSize = 50; // Reduced minimum cluster size
        
        for (let y = 0; y < tempCanvas.height; y += 3) { // Sampling more densely
          for (let x = 0; x < tempCanvas.width; x += 3) {
            const index = (y * tempCanvas.width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            
            // If this pixel is magenta and not already part of a cluster
            if (isMagenta(r, g, b) && !visited.has(`${x},${y}`)) {
              // Use flood fill to find the cluster
              const cluster = floodFill(data, tempCanvas.width, tempCanvas.height, x, y, visited);
              
              if (cluster.points.length >= clusterMinSize) {
                // Calculate the center of the cluster
                const centerX = cluster.sumX / cluster.points.length;
                const centerY = cluster.sumY / cluster.points.length;
                
                positions.push({
                  x: centerX / tempCanvas.width, // Store as ratio for resolution independence
                  y: centerY / tempCanvas.height,
                  size: cluster.points.length
                });
              }
            }
          }
        }
        
        setPadPositions(positions);
        
        // Draw detection results for visualization
        if (detectionCanvasRef.current) {
          const ctx = detectionCanvasRef.current.getContext('2d');
          detectionCanvasRef.current.width = tempCanvas.width;
          detectionCanvasRef.current.height = tempCanvas.height;
          
          // Draw original image
          ctx.drawImage(img, 0, 0);
          
          // Draw detected gap pad positions
          positions.forEach(pad => {
            ctx.beginPath();
            ctx.arc(
              pad.x * tempCanvas.width, 
              pad.y * tempCanvas.height, 
              10, 0, 2 * Math.PI
            );
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 3;
            ctx.stroke();
          });
          
          // Save the detection result for debugging
          localStorage.setItem('lastDetection', detectionCanvasRef.current.toDataURL());
        }
        
        console.log(`Detected ${positions.length} gap pads`);
        
        // Update the reference image with the detected positions
        if (key) {
          const updatedImages = { ...referenceImages };
          
          if (updatedImages[key]) {
            updatedImages[key] = {
              ...updatedImages[key],
              padPositions: positions
            };
            
            setReferenceImages(updatedImages);
            localStorage.setItem('gapPadReferenceImages', JSON.stringify(updatedImages));
          }
        }
        
        resolve(positions);
      };
      
      img.src = imageData;
    });
  };

  // Simple flood fill algorithm to find connected magenta pixels
  const floodFill = (imageData, width, height, startX, startY, visited) => {
    const queue = [{x: startX, y: startY}];
    const result = {points: [], sumX: 0, sumY: 0};
    
    while (queue.length > 0) {
      const {x, y} = queue.shift();
      const key = `${x},${y}`;
      
      // Skip if already visited or out of bounds
      if (visited.has(key) || x < 0 || y < 0 || x >= width || y >= height) {
        continue;
      }
      
      // Check if pixel is magenta
      const index = (y * width + x) * 4;
      const r = imageData[index];
      const g = imageData[index + 1];
      const b = imageData[index + 2];
      
      if (!isMagenta(r, g, b)) {
        continue;
      }
      
      // Mark as visited
      visited.add(key);
      result.points.push({x, y});
      result.sumX += x;
      result.sumY += y;
      
      // Add neighbors to queue (4-connected)
      queue.push({x: x+3, y: y}); // Reduced step size
      queue.push({x: x-3, y: y});
      queue.push({x: x, y: y+3});
      queue.push({x: x, y: y-3});
    }
    
    return result;
  };

  const captureReferenceImage = async () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }

    const video = videoRef.current;
    const canvas = canvasRef.current;
    
    if (!video || !canvas) return;
    
    const context = canvas.getContext('2d');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const imageData = canvas.toDataURL('image/jpeg');
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    // Detect gap pad positions
    setMessage("Analyzing gap pad positions...");
    
    // Save the reference image first
    const updatedImages = {
      ...referenceImages,
      [key]: {
        imageData,
        timestamp: new Date().toISOString(),
        serial: serial.trim().toUpperCase(),
        side,
        padPositions: [] // Will be updated after detection
      }
    };
    
    setReferenceImages(updatedImages);
    localStorage.setItem('gapPadReferenceImages', JSON.stringify(updatedImages));
    
    try {
      // Now detect pad positions and update the saved reference
      const positions = await detectGapPads(imageData, key);
      
      if (positions.length > 0) {
        setMessage(`Reference saved with ${positions.length} gap pads detected`);
      } else {
        setMessage("Warning: No gap pads detected. Verify the image.");
      }
    } catch (err) {
      console.error("Error detecting pads:", err);
      setMessage("Reference image saved, but pad detection failed");
    }
    
    setCaptureMode(false);
  };

  const validateCurrentView = async () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }
    
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    if (!referenceImages[key]) {
      setMessage(`No reference image found for ${serial} (${side})`);
      return;
    }
    
    const refImage = referenceImages[key];
    
    // Make sure we have pad positions
    let positions = refImage.padPositions || [];
    if (!positions || positions.length === 0) {
      try {
        positions = await detectGapPads(refImage.imageData, key);
      } catch (err) {
        console.error("Error detecting pads in reference:", err);
      }
    }
    
    setValidationResult({
      referenceImage: refImage.imageData,
      timestamp: refImage.timestamp,
      padPositions: positions
    });
    
    setShowOverlay(true);
    setMessage("Analyzing gap pad placement...");
    setValidationInProgress(true);
    
    // Start continuous validation
    if (validationIntervalRef.current) {
      clearInterval(validationIntervalRef.current);
    }
    
    validationIntervalRef.current = setInterval(() => {
      if (!videoRef.current || !canvasRef.current || !showOverlay) {
        return;
      }
      
      // Capture current frame
      const video = videoRef.current;
      const canvas = canvasRef.current;
      const context = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      context.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Get frame data for analysis
      const frameData = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = frameData.data;
      
      // Check reference positions for gap pads
      const referencePositions = refImage.padPositions || [];
      let matchedCount = 0;
      const tolerance = 0.05; // 5% tolerance for position matching
      
      if (referencePositions.length === 0) {
        setValidationStatus({
          status: "warning",
          matchPercentage: 0,
          matchedCount: 0,
          totalCount: 0
        });
        setMessage("No reference pad positions available. Please recapture reference.");
        return;
      }
      
      // For each reference position, check if there's a gap pad in the current frame
      referencePositions.forEach(refPad => {
        // Calculate pixel coordinates based on ratio
        const checkX = Math.floor(refPad.x * canvas.width);
        const checkY = Math.floor(refPad.y * canvas.height);
        
        // Check a small area around the expected position
        const areaSize = Math.max(20, Math.floor(Math.sqrt(refPad.size || 100) / 2));
        let foundMagenta = false;
        
        for (let dy = -areaSize; dy <= areaSize; dy += 4) {
          for (let dx = -areaSize; dx <= areaSize; dx += 4) {
            const x = checkX + dx;
            const y = checkY + dy;
            
            if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
              continue;
            }
            
            const index = (y * canvas.width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            
            if (isMagenta(r, g, b)) {
              foundMagenta = true;
              break;
            }
          }
          if (foundMagenta) break;
        }
        
        if (foundMagenta) {
          matchedCount++;
        }
      });
      
      // Calculate match percentage
      const matchPercentage = referencePositions.length > 0 
        ? (matchedCount / referencePositions.length) * 100 
        : 0;
      
      console.log(`Validation: ${matchedCount}/${referencePositions.length} pads matched (${matchPercentage.toFixed(2)}%)`);
      
      // Update validation status
      let status;
      if (matchPercentage >= 90) {
        status = "success";
      } else if (matchPercentage >= 70) {
        status = "warning";
      } else {
        status = "error";
      }
      
      setValidationStatus({
        status,
        matchPercentage,
        matchedCount,
        totalCount: referencePositions.length
      });
      
      // Update message
      if (status === "success") {
        setMessage(`Validation successful! ${matchedCount}/${referencePositions.length} gap pads detected.`);
      } else if (status === "warning") {
        setMessage(`Some gap pads may be misaligned (${matchedCount}/${referencePositions.length} detected).`);
      } else {
        setMessage(`Gap pad alignment incorrect (${matchedCount}/${referencePositions.length} detected).`);
      }
    }, 500); // Check every 500ms
  };

  const stopValidation = () => {
    if (validationIntervalRef.current) {
      clearInterval(validationIntervalRef.current);
    }
    setShowOverlay(false);
    setValidationInProgress(false);
    setValidationStatus(null);
  };

  const deleteReferenceImage = () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }
    
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    if (!referenceImages[key]) {
      setMessage(`No reference image found for ${serial} (${side})`);
      return;
    }
    
    const updatedImages = { ...referenceImages };
    delete updatedImages[key];
    
    setReferenceImages(updatedImages);
    localStorage.setItem('gapPadReferenceImages', JSON.stringify(updatedImages));
    setMessage(`Reference image deleted for ${serial} (${side})`);
    
    if (validationResult) {
      stopValidation();
    }
  };

  const hasReferenceImage = () => {
    if (!serial.trim()) return false;
    const key = `${serial.trim().toUpperCase()}_${side}`;
    return !!referenceImages[key];
  };

  // Debug function to display color detection info
  const testColorDetection = () => {
    if (!canvasRef.current || !videoRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const video = videoRef.current;
    
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // Apply magenta detection
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      if (isMagenta(r, g, b)) {
        // Highlight detected pixels
        data[i] = 0; // R
        data[i + 1] = 255; // G
        data[i + 2] = 0; // B
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    localStorage.setItem('colorTest', canvas.toDataURL());
    
    setMessage("Color detection test completed");
  };

  return (
    <div style={{ minHeight:"100vh", background:"#0a0a0a", color:"#e5e5e5", display:"flex", flexDirection:"column" }}>
      <header style={{ padding:"1rem", borderBottom:"1px solid #27272a" }}>
        <div>Gap Pad Web Validator</div>
      </header>

      <main style={{ flex:1, display:"grid", gridTemplateColumns:"2fr 1fr" }}>
        <section style={{ padding:"1rem" }}>
          <div style={{ position:"relative", background:"black", borderRadius:"12px", overflow:"hidden" }}>
            <video ref={videoRef} style={{ width:"100%", aspectRatio:"16/9", objectFit:"contain", display: showOverlay ? "none" : "block" }} playsInline autoPlay muted />
            
            {showOverlay && validationResult && (
              <div style={{ width:"100%", aspectRatio:"16/9", position:"relative" }}>
                <img 
                  src={validationResult.referenceImage} 
                  alt="Reference" 
                  style={{ width:"100%", height:"100%", objectFit:"contain", opacity:0.6 }} 
                />
                <video 
                  ref={videoRef} 
                  style={{ position:"absolute", top:0, left:0, width:"100%", height:"100%", objectFit:"contain", opacity:0.7, mixBlendMode:"difference" }} 
                  playsInline 
                  autoPlay 
                  muted 
                />
                
                {/* Draw pad position markers */}
                {validationResult.padPositions && validationResult.padPositions.length > 0 && 
                  validationResult.padPositions.map((pad, index) => (
                    <div
                      key={index}
                      style={{
                        position: "absolute",
                        left: `${pad.x * 100}%`,
                        top: `${pad.y * 100}%`,
                        width: "24px",
                        height: "24px",
                        borderRadius: "50%",
                        border: "3px solid lime",
                        transform: "translate(-50%, -50%)",
                        boxShadow: "0 0 0 2px rgba(0,0,0,0.7)",
                        pointerEvents: "none"
                      }}
                    />
                  ))
                }
                
                <div style={{ position:"absolute", bottom:"10px", left:"10px", background:"rgba(0,0,0,0.7)", padding:"8px", borderRadius:"4px", fontSize:"12px" }}>
                  Reference captured: {new Date(validationResult.timestamp).toLocaleString()}
                </div>
                
                {/* Validation status indicator */}
                {validationStatus && (
                  <div 
                    style={{ 
                      position:"absolute", 
                      top:"10px", 
                      left:"10px", 
                      background: validationStatus.status === "success" ? "rgba(22, 163, 74, 0.8)" : 
                                 validationStatus.status === "warning" ? "rgba(245, 158, 11, 0.8)" : 
                                 "rgba(225, 29, 72, 0.8)",
                      padding:"12px 16px", 
                      borderRadius:"4px",
                      fontSize: "16px",
                      fontWeight: "bold",
                      boxShadow: "0 2px 5px rgba(0,0,0,0.3)",
                      zIndex: 10
                    }}
                  >
                    {validationStatus.status === "success" ? "✓ PASS" : 
                     validationStatus.status === "warning" ? "⚠ CHECK" : "✗ FAIL"}
                     <div style={{ fontSize: "14px", fontWeight: "normal", marginTop: "4px" }}>
                       Match: {Math.round(validationStatus.matchPercentage)}%
                     </div>
                  </div>
                )}
                
                <button 
                  style={{ position:"absolute", top:"10px", right:"10px", background:"#e11d48", padding:"8px", borderRadius:"4px", border:"none", color:"white" }}
                  onClick={stopValidation}
                >
                  Exit Overlay
                </button>
              </div>
            )}
            
            <canvas ref={canvasRef} style={{ display: "none" }} />
            <canvas ref={detectionCanvasRef} style={{ display: "none" }} />
            
            {validationMode && !showOverlay && (
              <div style={{ position:"absolute", top:"10px", left:"10px", background:"rgba(0,0,0,0.6)", padding:"4px 8px", borderRadius:"8px" }}>
                Validation Mode Active
              </div>
            )}
            
            {captureMode && !showOverlay && (
              <div style={{ position:"absolute", top:"10px", left:"10px", background:"rgba(0,0,0,0.6)", padding:"4px 8px", borderRadius:"8px", color:"#f87171" }}>
                Capture Mode Active
              </div>
            )}
          </div>
          
          <div style={{ marginTop:"1rem", display:"flex", gap:"0.5rem", flexWrap:"wrap" }}>
            {validationMode ? (
              <>
                <button onClick={() => setValidationMode(false)}>
                  Exit Validation Mode
                </button>
                <button 
                  onClick={validateCurrentView} 
                  style={{ background: "#2563eb", color: "white", border: "none", padding: "8px 16px", borderRadius: "4px" }}
                  disabled={!hasReferenceImage()}
                >
                  Compare with Reference
                </button>
              </>
            ) : captureMode ? (
              <>
                <button onClick={() => setCaptureMode(false)}>
                  Cancel Capture
                </button>
                <button 
                  onClick={captureReferenceImage}
                  style={{ background: "#16a34a", color: "white", border: "none", padding: "8px 16px", borderRadius: "4px" }}
                >
                  Capture Reference Image
                </button>
                <button 
                  onClick={testColorDetection}
                  style={{ background: "#6366f1", color: "white", border: "none", padding: "8px 16px", borderRadius: "4px" }}
                >
                  Test Color Detection
                </button>
              </>
            ) : (
              <>
                <button onClick={() => setValidationMode(true)}>
                  Enter Validation Mode
                </button>
                <button onClick={() => setCaptureMode(true)}>
                  Set Reference Image
                </button>
              </>
            )}
          </div>
          
          {message && (
            <div style={{ 
              marginTop:"0.75rem", 
              padding:"0.75rem", 
              background: message.includes("success") ? "rgba(22, 163, 74, 0.2)" : 
                        message.includes("incorrect") ? "rgba(225, 29, 72, 0.2)" : 
                        "rgba(0,0,0,0.4)", 
              borderRadius:"4px", 
              fontSize:"1rem",
              boxShadow: "0 1px 3px rgba(0,0,0,0.2)"
            }}>
              {message}
            </div>
          )}
        </section>

        <aside style={{ padding:"1rem", borderLeft:"1px solid #27272a" }}>
          <div>
            <label>Serial Number</label><br/>
            <input 
              value={serial} 
              onChange={e => setSerial(e.target.value)} 
              placeholder="Enter serial" 
              style={{ width:"100%", padding:"8px", marginTop:"4px", background:"#1f1f1f", border:"1px solid #3f3f3f", color:"#e5e5e5", borderRadius:"4px" }} 
            />
          </div>
          
          <div style={{ marginTop:"1rem" }}>
            <label>Gap Pad Side</label><br/>
            <div style={{ display:"flex", gap:"0.5rem", marginTop:"4px" }}>
              <button 
                onClick={() => setSide("back")} 
                style={{ 
                  padding:"8px 16px", 
                  background: side === "back" ? "#2563eb" : "#1f1f1f",
                  color: side === "back" ? "white" : "#e5e5e5",
                  border: "none",
                  borderRadius: "4px"
                }}
              >
                Back
              </button>
              <button 
                onClick={() => setSide("front")} 
                style={{ 
                  padding:"8px 16px", 
                  background: side === "front" ? "#2563eb" : "#1f1f1f",
                  color: side === "front" ? "white" : "#e5e5e5",
                  border: "none",
                  borderRadius: "4px"
                }}
              >
                Front
              </button>
            </div>
          </div>
          
          <div style={{ marginTop:"1rem", fontSize:"0.8rem", color:"#a1a1aa" }}>
            Product code: {(serial||"").slice(0,6).toUpperCase()} ({side})
          </div>
          
          {hasReferenceImage() && (
            <div style={{ marginTop:"1rem" }}>
              <div style={{ fontSize:"0.8rem", marginBottom:"0.5rem", color:"#34d399" }}>
                ✓ Reference image available
              </div>
              
              {/* Show detected pad count if available */}
              {referenceImages[`${serial.trim().toUpperCase()}_${side}`]?.padPositions && (
                <div style={{ fontSize:"0.8rem", marginBottom:"0.5rem", color:"#94a3b8" }}>
                  {referenceImages[`${serial.trim().toUpperCase()}_${side}`].padPositions.length || 0} gap pads detected
                </div>
              )}
              
              <button 
                onClick={deleteReferenceImage}
                style={{ background:"#ef4444", color:"white", border:"none", padding:"4px 8px", borderRadius:"4px", fontSize:"0.8rem" }}
              >
                Delete Reference
              </button>
              <div style={{ marginTop:"0.5rem" }}>
                <button 
                  onClick={() => {
                    const key = `${serial.trim().toUpperCase()}_${side}`;
                    if (referenceImages[key]) {
                      setValidationResult({
                        referenceImage: referenceImages[key].imageData,
                        timestamp: referenceImages[key].timestamp,
                        padPositions: referenceImages[key].padPositions || []
                      });
                      setShowOverlay(true);
                      setValidationStatus(null); // No validation status when just viewing
                    }
                  }}
                  style={{ background:"#1f1f1f", border:"none", padding:"4px 8px", borderRadius:"4px", fontSize:"0.8rem" }}
                >
                  View Reference
                </button>
              </div>
            </div>
          )}
          
          <div style={{ marginTop:"1.5rem", fontSize:"0.8rem", color:"#a1a1aa", borderTop:"1px solid #27272a", paddingTop:"1rem" }}>
            <div>Reference Library:</div>
            <div style={{ fontSize:"0.7rem", marginTop:"0.5rem" }}>
              {Object.keys(referenceImages).length} images stored
            </div>
          </div>

          <div style={{ marginTop:"1.5rem", fontSize:"0.8rem", color:"#a1a1aa", borderTop:"1px solid #27272a", paddingTop:"1rem" }}>
            <div>Detection Settings:</div>
            <div style={{ fontSize:"0.7rem", marginTop:"0.5rem", lineHeight: "1.4" }}>
              Looking for magenta/pink colored gap pads<br/>
              Tolerance: 5%<br/>
              Minimum size: 50px
            </div>
          </div>
        </aside>
      </main>
    </div>
  );
}
