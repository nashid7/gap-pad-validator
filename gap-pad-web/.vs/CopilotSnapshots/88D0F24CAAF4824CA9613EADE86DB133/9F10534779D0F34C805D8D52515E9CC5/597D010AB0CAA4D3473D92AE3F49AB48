import React, { useRef, useState, useEffect } from "react";

export default function App() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const detectionCanvasRef = useRef(null);
  const [serial, setSerial] = useState("");
  const [side, setSide] = useState("back");
  const [validationMode, setValidationMode] = useState(false);
  const [referenceImages, setReferenceImages] = useState({});
  const [captureMode, setCaptureMode] = useState(false);
  const [validationResult, setValidationResult] = useState(null);
  const [showOverlay, setShowOverlay] = useState(false);
  const [message, setMessage] = useState("");
  const [validationStatus, setValidationStatus] = useState(null);
  const validationIntervalRef = useRef(null);
  const [showInstructions, setShowInstructions] = useState(true);
  const [detectedPads, setDetectedPads] = useState([]);
  const [showDetectionOverlay, setShowDetectionOverlay] = useState(false);

  useEffect(() => {
    // Load saved reference images from localStorage on component mount
    const savedImages = localStorage.getItem('gapPadReferenceImages');
    if (savedImages) {
      try {
        const parsed = JSON.parse(savedImages);
        setReferenceImages(parsed);
      } catch (e) {
        console.error("Failed to parse saved images", e);
        setMessage("Error loading saved images");
      }
    }
  }, []);

  useEffect(() => {
    (async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: "environment",
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          }, 
          audio: false 
        });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          await videoRef.current.play();
        }
      } catch (err) {
        console.error("Camera error", err);
        setMessage("Camera access error. Please check permissions.");
      }
    })();

    // Cleanup function for validation interval
    return () => {
      if (validationIntervalRef.current) {
        clearInterval(validationIntervalRef.current);
      }
    };
  }, []);

  // Advanced gap pad detection based on your Python script approach
  const detectGapPads = async (imageData) => {
    return new Promise((resolve) => {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      
      const img = new Image();
      img.onload = () => {
        console.log(`Starting detection on image: ${img.width}x${img.height}`);
        
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        tempCtx.drawImage(img, 0, 0);
        
        const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imgData.data;
        
        console.log('Converting to HSV...');
        // Convert to HSV for better color detection (similar to Python OpenCV)
        const hsvData = rgbToHsv(data, tempCanvas.width, tempCanvas.height);
        
        console.log('Creating color mask...');
        // Create mask for pink/magenta colors
        const mask = createColorMask(hsvData, tempCanvas.width, tempCanvas.height);
        
        // Count mask pixels for debugging
        let maskPixelCount = 0;
        for (let i = 0; i < mask.length; i++) {
          if (mask[i] === 255) maskPixelCount++;
        }
        console.log(`Color mask contains ${maskPixelCount} pink/magenta pixels (${((maskPixelCount/(tempCanvas.width*tempCanvas.height))*100).toFixed(2)}% of image)`);
        
        console.log('Finding contours...');
        // Find contours (connected components)
        const contours = findContours(mask, tempCanvas.width, tempCanvas.height);
        
        console.log('Filtering gap pads...');
        // Filter contours by size and aspect ratio (similar to your Python script)
        const validPads = filterGapPads(contours, tempCanvas.width, tempCanvas.height);
        
        // Draw detection results
        drawDetectionResults(tempCtx, validPads, tempCanvas.width, tempCanvas.height);
        
        console.log(`✅ Detection complete: Found ${validPads.length} gap pads`);
        resolve(validPads);
      };
      
      img.onerror = (error) => {
        console.error('Image loading error:', error);
        resolve([]);
      };
      
      img.src = imageData;
    });
  };

  // Convert RGB to HSV (similar to OpenCV cvtColor)
  const rgbToHsv = (data, width, height) => {
    const hsvData = new Uint8Array(width * height * 3);
    
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i] / 255;
      const g = data[i + 1] / 255;
      const b = data[i + 2] / 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const delta = max - min;
      
      let h = 0;
      let s = 0;
      const v = max;
      
      if (delta !== 0) {
        s = delta / max;
        
        if (max === r) {
          h = ((g - b) / delta) % 6;
        } else if (max === g) {
          h = (b - r) / delta + 2;
        } else {
          h = (r - g) / delta + 4;
        }
        h *= 60;
        if (h < 0) h += 360;
      }
      
      const pixelIndex = (i / 4) * 3;
      hsvData[pixelIndex] = h;           // H: 0-360
      hsvData[pixelIndex + 1] = s * 100; // S: 0-100
      hsvData[pixelIndex + 2] = v * 100; // V: 0-100
    }
    
    return hsvData;
  };

  // Create mask for pink/magenta colors (similar to cv2.inRange)
  const createColorMask = (hsvData, width, height) => {
    const mask = new Uint8Array(width * height);
    
    // Updated Pink/Magenta HSV ranges - broader detection
    // Range 1: Magenta (300-360°)
    const lowerPink1 = [280, 20, 30];  // Broader magenta range
    const upperPink1 = [360, 100, 100];
    
    // Range 2: Red-Pink (0-40°) 
    const lowerPink2 = [0, 20, 30];    // Broader red-pink range
    const upperPink2 = [40, 100, 100];
    
    // Range 3: Purple-Pink (240-280°)
    const lowerPink3 = [240, 20, 30];  // Purple-pink range
    const upperPink3 = [280, 100, 100];
    
    for (let i = 0; i < hsvData.length; i += 3) {
      const h = hsvData[i];
      const s = hsvData[i + 1];
      const v = hsvData[i + 2];
      
      const inRange1 = (h >= lowerPink1[0] && h <= upperPink1[0] && 
                       s >= lowerPink1[1] && s <= upperPink1[1] && 
                       v >= lowerPink1[2] && v <= upperPink1[2]);
      
      const inRange2 = (h >= lowerPink2[0] && h <= upperPink2[0] && 
                       s >= lowerPink2[1] && s <= upperPink2[1] && 
                       v >= lowerPink2[2] && v <= upperPink2[2]);
      
      const inRange3 = (h >= lowerPink3[0] && h <= upperPink3[0] && 
                       s >= lowerPink3[1] && s <= upperPink3[1] && 
                       v >= lowerPink3[2] && v <= upperPink3[2]);
      
      mask[i / 3] = (inRange1 || inRange2 || inRange3) ? 255 : 0;
    }
    
    return mask;
  };

  // Find contours (connected components) - simplified version of cv2.findContours
  const findContours = (mask, width, height) => {
    const visited = new Set();
    const contours = [];
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const index = y * width + x;
        
        if (mask[index] === 255 && !visited.has(index)) {
          const contour = floodFill(mask, width, height, x, y, visited);
          if (contour.points.length > 50) { // Minimum size threshold
            contours.push(contour);
          }
        }
      }
    }
    
    return contours;
  };

  // Flood fill to find connected components
  const floodFill = (mask, width, height, startX, startY, visited) => {
    const queue = [{x: startX, y: startY}];
    const points = [];
    let minX = startX, maxX = startX, minY = startY, maxY = startY;
    
    while (queue.length > 0) {
      const {x, y} = queue.shift();
      const index = y * width + x;
      
      if (visited.has(index) || x < 0 || y < 0 || x >= width || y >= height || mask[index] !== 255) {
        continue;
      }
      
      visited.add(index);
      points.push({x, y});
      
      // Update bounding box
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
      
      // Add 4-connected neighbors
      queue.push({x: x + 1, y: y});
      queue.push({x: x - 1, y: y});
      queue.push({x: x, y: y + 1});
      queue.push({x: x, y: y - 1});
    }
    
    return {
      points,
      boundingBox: {
        x: minX,
        y: minY,
        width: maxX - minX + 1,
        height: maxY - minY + 1
      }
    };
  };

  // Filter gap pads based on size and aspect ratio (similar to your Python script logic)
  const filterGapPads = (contours, imageWidth, imageHeight) => {
    const validPads = [];
    
    console.log(`Filtering ${contours.length} contours found`);
    
    contours.forEach((contour, index) => {
      const bbox = contour.boundingBox;
      const area = bbox.width * bbox.height;
      const aspectRatio = bbox.width / bbox.height;
      
      // More lenient filter criteria
      const minArea = 100;   // Reduced minimum area
      const maxArea = 8000;  // Increased maximum area  
      const minAspectRatio = 0.3;  // More lenient aspect ratio
      const maxAspectRatio = 3.0;  // More lenient aspect ratio
      
      // Additional size checks relative to image
      const relativeArea = area / (imageWidth * imageHeight);
      
      console.log(`Contour ${index}: area=${area}, aspect=${aspectRatio.toFixed(2)}, relArea=${(relativeArea*100).toFixed(4)}%`);
      
      if (area >= minArea && area <= maxArea &&
          aspectRatio >= minAspectRatio && aspectRatio <= maxAspectRatio &&
          relativeArea >= 0.00005 && relativeArea <= 0.08) { // More lenient relative area
        
        console.log(`✓ Contour ${index} accepted as gap pad`);
        
        validPads.push({
          x: (bbox.x + bbox.width / 2) / imageWidth,  // Center X as ratio
          y: (bbox.y + bbox.height / 2) / imageHeight, // Center Y as ratio
          width: bbox.width / imageWidth,
          height: bbox.height / imageHeight,
          area: area,
          aspectRatio: aspectRatio,
          boundingBox: bbox,
          id: `pad_${bbox.x}_${bbox.y}`
        });
      } else {
        console.log(`✗ Contour ${index} rejected: area=${area >= minArea && area <= maxArea}, aspect=${aspectRatio >= minAspectRatio && aspectRatio <= maxAspectRatio}, relArea=${relativeArea >= 0.00005 && relativeArea <= 0.08}`);
      }
    });
    
    console.log(`Filtered down to ${validPads.length} valid gap pads`);
    return validPads;
  };

  // Draw detection results (similar to cv2.rectangle and cv2.putText)
  const drawDetectionResults = (ctx, pads, width, height) => {
    pads.forEach((pad, index) => {
      const bbox = pad.boundingBox;
      
      // Draw green rectangle
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 3;
      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
      
      // Draw label background
      const label = `P${index + 1}`;
      ctx.font = '16px Arial';
      const textWidth = ctx.measureText(label).width;
      
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(bbox.x, bbox.y - 20, textWidth + 8, 20);
      
      // Draw label text
      ctx.fillStyle = '#000000';
      ctx.fillText(label, bbox.x + 4, bbox.y - 6);
    });
  };

  // Test gap pad detection on current video frame
  const testDetection = async () => {
    if (!videoRef.current || !canvasRef.current) return;
    
    const video = videoRef.current;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const imageData = canvas.toDataURL('image/jpeg');
    setMessage("Running gap pad detection...");
    
    try {
      const detectedPads = await detectGapPads(imageData);
      setDetectedPads(detectedPads);
      setShowDetectionOverlay(true);
      setMessage(`✅ Detection complete! Found ${detectedPads.length} gap pads`);
    } catch (error) {
      console.error("Detection error:", error);
      setMessage("❌ Detection failed. Please try again.");
    }
  };

  const captureReferenceImage = async () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }

    const video = videoRef.current;
    const canvas = canvasRef.current;
    
    if (!video || !canvas) return;
    
    const context = canvas.getContext('2d');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const imageData = canvas.toDataURL('image/jpeg');
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    setMessage("Detecting gap pads automatically...");
    
    try {
      // Automatically detect gap pads
      const detectedPads = await detectGapPads(imageData);
      
      if (detectedPads.length === 0) {
        setMessage("⚠️ No gap pads detected. Please ensure good lighting and try again.");
        return;
      }
      
      // Save the reference image with detected positions
      const updatedImages = {
        ...referenceImages,
        [key]: {
          imageData,
          timestamp: new Date().toISOString(),
          serial: serial.trim().toUpperCase(),
          side,
          padPositions: detectedPads
        }
      };
      
      setReferenceImages(updatedImages);
      localStorage.setItem('gapPadReferenceImages', JSON.stringify(updatedImages));
      setMessage(`✅ Reference saved! Automatically detected ${detectedPads.length} gap pads`);
      setCaptureMode(false);
      
    } catch (error) {
      console.error("Detection error:", error);
      setMessage("❌ Detection failed. Please try again with better lighting.");
    }
  };

  const validateCurrentView = async () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }
    
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    if (!referenceImages[key]) {
      setMessage(`No reference image found for ${serial} (${side})`);
      return;
    }
    
    const refImage = referenceImages[key];
    
    if (!refImage.padPositions || refImage.padPositions.length === 0) {
      setMessage("No gap pad positions found in reference. Please recapture.");
      return;
    }
    
    setValidationResult({
      referenceImage: refImage.imageData,
      timestamp: refImage.timestamp,
      padPositions: refImage.padPositions
    });
    
    setShowOverlay(true);
    setMessage("🔍 Starting real-time validation...");
    
    // Start continuous validation with automatic detection
    if (validationIntervalRef.current) {
      clearInterval(validationIntervalRef.current);
    }
    
    validationIntervalRef.current = setInterval(async () => {
      if (!videoRef.current || !showOverlay) {
        return;
      }
      
      try {
        // Capture current frame
        const video = videoRef.current;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCanvas.width = video.videoWidth;
        tempCanvas.height = video.videoHeight;
        tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
        
        const currentImageData = tempCanvas.toDataURL('image/jpeg');
        
        // Detect gap pads in current frame
        const currentPads = await detectGapPads(currentImageData);
        
        // Compare with reference
        const referencePositions = refImage.padPositions || [];
        let matchedCount = 0;
        const tolerance = 0.05; // 5% tolerance for position matching
        
        // For each reference pad, find if there's a matching detected pad
        referencePositions.forEach(refPad => {
          const hasMatch = currentPads.some(currentPad => {
            const xDiff = Math.abs(refPad.x - currentPad.x);
            const yDiff = Math.abs(refPad.y - currentPad.y);
            return xDiff <= tolerance && yDiff <= tolerance;
          });
          
          if (hasMatch) {
            matchedCount++;
          }
        });
        
        // Calculate match percentage
        const matchPercentage = referencePositions.length > 0 
          ? (matchedCount / referencePositions.length) * 100 
          : 0;
        
        // Update validation status
        let status;
        if (matchPercentage >= 90) {
          status = "success";
        } else if (matchPercentage >= 70) {
          status = "warning";
        } else {
          status = "error";
        }
        
        setValidationStatus({
          status,
          matchPercentage,
          matchedCount,
          totalCount: referencePositions.length,
          currentPads: currentPads.length
        });
        
        // Update message
        if (status === "success") {
          setMessage(`✅ VALIDATION PASSED! ${matchedCount}/${referencePositions.length} gap pads correctly placed`);
        } else if (status === "warning") {
          setMessage(`⚠️ Some gaps detected: ${matchedCount}/${referencePositions.length} gap pads found`);
        } else {
          setMessage(`❌ VALIDATION FAILED: Only ${matchedCount}/${referencePositions.length} gap pads detected`);
        }
        
      } catch (error) {
        console.error("Validation error:", error);
      }
    }, 2000); // Check every 2 seconds
  };

  const stopValidation = () => {
    if (validationIntervalRef.current) {
      clearInterval(validationIntervalRef.current);
    }
    setShowOverlay(false);
    setValidationStatus(null);
  };

  const deleteReferenceImage = () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }
    
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    if (!referenceImages[key]) {
      setMessage(`No reference image found for ${serial} (${side})`);
      return;
    }
    
    const updatedImages = { ...referenceImages };
    delete updatedImages[key];
    
    setReferenceImages(updatedImages);
    localStorage.setItem('gapPadReferenceImages', JSON.stringify(updatedImages));
    setMessage(`Reference image deleted for ${serial} (${side})`);
    
    if (validationResult) {
      stopValidation();
    }
  };

  const hasReferenceImage = () => {
    if (!serial.trim()) return false;
    const key = `${serial.trim().toUpperCase()}_${side}`;
    return !!referenceImages[key];
  };

  return (
    <div style={{ minHeight:"100vh", background:"#0a0a0a", color:"#e5e5e5", display:"flex", flexDirection:"column" }}>
      <header style={{ padding:"1rem", borderBottom:"1px solid #27272a" }}>
        <div style={{ fontSize: "1.5rem", fontWeight: "bold" }}>🔬 AI Gap Pad Validator</div>
        <div style={{ fontSize: "0.9rem", color: "#a1a1aa" }}>Automatic detection and validation using computer vision</div>
      </header>

      <main style={{ flex:1, display:"grid", gridTemplateColumns:"2fr 1fr" }}>
        <section style={{ padding:"1rem" }}>
          {/* Instructions Panel */}
          {showInstructions && (
            <div style={{ 
              background:"rgba(34, 197, 94, 0.1)", 
              border: "1px solid rgba(34, 197, 94, 0.3)",
              padding:"1rem", 
              borderRadius:"8px", 
              marginBottom: "1rem"
            }}>
              <div style={{ fontSize: "1rem", fontWeight: "bold", color: "#22c55e", marginBottom: "0.5rem" }}>
                🤖 AI-Powered Detection:
              </div>
              <div style={{ fontSize: "0.9rem", lineHeight: "1.5" }}>
                <strong>1. Auto-Create Reference:</strong> Enter serial → "Set Reference" → AI detects all gap pads automatically<br/>
                <strong>2. Auto-Validate:</strong> Enter same serial → "Enter Validation Mode" → "Compare with Reference"<br/>
                <strong>3. Results:</strong> Real-time PASS/FAIL based on AI detection comparison
              </div>
              <button 
                onClick={() => setShowInstructions(false)}
                style={{ marginTop: "0.5rem", background: "transparent", border: "1px solid #22c55e", color: "#22c55e", padding: "4px 8px", borderRadius: "4px", fontSize: "0.8rem" }}
              >
                Got it!
              </button>
            </div>
          )}

          <div style={{ position:"relative", background:"black", borderRadius:"12px", overflow:"hidden" }}>
            <video 
              ref={videoRef} 
              style={{ 
                width:"100%", 
                aspectRatio:"16/9", 
                objectFit:"contain", 
                display: (showOverlay || showDetectionOverlay) ? "none" : "block" 
              }} 
              playsInline 
              autoPlay 
              muted 
            />
            
            {/* Detection test overlay */}
            {showDetectionOverlay && (
              <div style={{ position: "relative", width: "100%", aspectRatio: "16/9" }}>
                <canvas
                  ref={canvasRef}
                  style={{ 
                    width: "100%", 
                    height: "100%", 
                    objectFit: "contain"
                  }}
                />
                
                {/* Show detected pads as overlays */}
                {detectedPads.map((pad, index) => (
                  <div
                    key={index}
                    style={{
                      position: "absolute",
                      left: `${pad.x * 100}%`,
                      top: `${pad.y * 100}%`,
                      width: `${pad.width * 100}%`,
                      height: `${pad.height * 100}%`,
                      border: "3px solid #00ff00",
                      transform: "translate(-50%, -50%)",
                      pointerEvents: "none",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      color: "#00ff00",
                      fontWeight: "bold",
                      fontSize: "12px",
                      background: "rgba(0,255,0,0.1)"
                    }}
                  >
                    P{index + 1}
                  </div>
                ))}
                
                <button 
                  style={{ position:"absolute", top:"15px", right:"15px", background:"#ef4444", padding:"8px 12px", borderRadius:"6px", border:"none", color:"white", fontWeight: "bold" }}
                  onClick={() => setShowDetectionOverlay(false)}
                >
                  Close Detection Test
                </button>
              </div>
            )}
            
            {/* Validation overlay */}
            {showOverlay && validationResult && (
              <div style={{ width:"100%", aspectRatio:"16/9", position:"relative" }}>
                <img 
                  src={validationResult.referenceImage} 
                  alt="Reference" 
                  style={{ width:"100%", height:"100%", objectFit:"contain", opacity:0.7 }} 
                />
                <video 
                  ref={videoRef} 
                  style={{ position:"absolute", top:0, left:0, width:"100%", height:"100%", objectFit:"contain", opacity:0.5, mixBlendMode:"difference" }} 
                  playsInline 
                  autoPlay 
                  muted 
                />
                
                {/* Draw reference pad position markers */}
                {validationResult.padPositions && validationResult.padPositions.map((pad, index) => (
                  <div
                    key={index}
                    style={{
                      position: "absolute",
                      left: `${pad.x * 100}%`,
                      top: `${pad.y * 100}%`,
                      width: `${(pad.width || 0.03) * 100}%`,
                      height: `${(pad.height || 0.03) * 100}%`,
                      border: "3px solid #00ff00",
                      transform: "translate(-50%, -50%)",
                      pointerEvents: "none",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      color: "#00ff00",
                      fontWeight: "bold",
                      fontSize: "12px",
                      background: "rgba(0,0,0,0.5)"
                    }}
                  >
                    {index + 1}
                  </div>
                ))}
                
                {/* Validation status indicator */}
                {validationStatus && (
                  <div 
                    style={{ 
                      position:"absolute", 
                      top:"20px", 
                      left:"20px", 
                      background: validationStatus.status === "success" ? "rgba(34, 197, 94, 0.95)" : 
                                 validationStatus.status === "warning" ? "rgba(245, 158, 11, 0.95)" : 
                                 "rgba(239, 68, 68, 0.95)",
                      padding:"16px 20px", 
                      borderRadius:"8px",
                      fontSize: "18px",
                      fontWeight: "bold",
                      boxShadow: "0 4px 12px rgba(0,0,0,0.3)",
                      zIndex: 10,
                      maxWidth: "300px"
                    }}
                  >
                    {validationStatus.status === "success" ? "✅ PASS" : 
                     validationStatus.status === "warning" ? "⚠️ CHECK" : "❌ FAIL"}
                     <div style={{ fontSize: "14px", fontWeight: "normal", marginTop: "4px" }}>
                       Expected: {validationStatus.totalCount} | Found: {validationStatus.currentPads} | Match: {validationStatus.matchedCount} ({Math.round(validationStatus.matchPercentage)}%)
                     </div>
                  </div>
                )}
                
                <button 
                  style={{ position:"absolute", top:"20px", right:"20px", background:"#ef4444", padding:"12px 16px", borderRadius:"8px", border:"none", color:"white", fontSize: "16px", fontWeight: "bold" }}
                  onClick={stopValidation}
                >
                  Exit Validation
                </button>
              </div>
            )}
            
            {/* Mode indicators */}
            {captureMode && !showOverlay && !showDetectionOverlay && (
              <div style={{ position:"absolute", top:"15px", left:"15px", background:"rgba(34, 197, 94, 0.8)", padding:"8px 12px", borderRadius:"8px", color:"white", fontWeight: "bold" }}>
                🤖 Ready to auto-detect gap pads
              </div>
            )}
            
            {validationMode && !showOverlay && !captureMode && !showDetectionOverlay && (
              <div style={{ position:"absolute", top:"15px", left:"15px", background:"rgba(59, 130, 246, 0.8)", padding:"8px 12px", borderRadius:"8px", color:"white", fontWeight: "bold" }}>
                🔍 AI Validation Mode Ready
              </div>
            )}
          </div>
          
          {/* Control Buttons */}
          <div style={{ marginTop:"1rem", display:"flex", gap:"0.5rem", flexWrap:"wrap" }}>
            {validationMode ? (
              <>
                <button 
                  onClick={() => setValidationMode(false)}
                  style={{ background: "#6b7280", color: "white", border: "none", padding: "12px 16px", borderRadius: "6px", fontSize: "14px" }}
                >
                  Exit Validation Mode
                </button>
                <button 
                  onClick={validateCurrentView} 
                  style={{ background: "#3b82f6", color: "white", border: "none", padding: "12px 16px", borderRadius: "6px", fontSize: "14px", fontWeight: "bold" }}
                  disabled={!hasReferenceImage()}
                >
                  🤖 AI Compare with Reference
                </button>
              </>
            ) : captureMode ? (
              <>
                <button 
                  onClick={() => setCaptureMode(false)}
                  style={{ background: "#6b7280", color: "white", border: "none", padding: "12px 16px", borderRadius: "6px", fontSize: "14px" }}
                >
                  Cancel
                </button>
                <button 
                  onClick={captureReferenceImage}
                  style={{ background: "#22c55e", color: "white", border: "none", padding: "12px 16px", borderRadius: "6px", fontSize: "14px", fontWeight: "bold" }}
                >
                  🤖 Auto-Detect & Save Reference
                </button>
              </>
            ) : (
              <>
                <button 
                  onClick={() => setValidationMode(true)}
                  style={{ background: "#3b82f6", color: "white", border: "none", padding: "12px 16px", borderRadius: "6px", fontSize: "14px", fontWeight: "bold" }}
                >
                  🔍 Enter Validation Mode
                </button>
                <button 
                  onClick={() => setCaptureMode(true)}
                  style={{ background: "#22c55e", color: "white", border: "none", padding: "12px 16px", borderRadius: "6px", fontSize: "14px", fontWeight: "bold" }}
                >
                  🤖 AI Set Reference Image
                </button>
                <button 
                  onClick={testDetection}
                  style={{ background: "#8b5cf6", color: "white", border: "none", padding: "12px 16px", borderRadius: "6px", fontSize: "14px", fontWeight: "bold" }}
                >
                  🧪 Test AI Detection
                </button>
              </>
            )}
          </div>
          
          {/* Message Display */}
          {message && (
            <div style={{ 
              marginTop:"1rem", 
              padding:"1rem", 
              background: message.includes("PASSED") || message.includes("saved") || message.includes("complete") ? "rgba(34, 197, 94, 0.2)" : 
                        message.includes("FAILED") || message.includes("failed") ? "rgba(239, 68, 68, 0.2)" : 
                        message.includes("gaps detected") || message.includes("Some") ? "rgba(245, 158, 11, 0.2)" :
                        "rgba(107, 114, 128, 0.2)", 
              borderRadius:"8px", 
              fontSize:"1rem",
              fontWeight: "500"
            }}>
              {message}
            </div>
          )}
        </section>

        <aside style={{ padding:"1rem", borderLeft:"1px solid #27272a" }}>
          <div>
            <label style={{ fontSize: "0.9rem", fontWeight: "600" }}>Serial Number</label><br/>
            <input 
              value={serial} 
              onChange={e => setSerial(e.target.value)} 
              placeholder="Enter serial number" 
              style={{ width:"100%", padding:"12px", marginTop:"8px", background:"#1f2937", border:"1px solid #374151", color:"#e5e7eb", borderRadius:"6px", fontSize: "16px" }} 
            />
          </div>
          
          <div style={{ marginTop:"1.5rem" }}>
            <label style={{ fontSize: "0.9rem", fontWeight: "600" }}>Gap Pad Side</label><br/>
            <div style={{ display:"flex", gap:"0.5rem", marginTop:"8px" }}>
              <button 
                onClick={() => setSide("back")} 
                style={{ 
                  padding:"12px 20px", 
                  background: side === "back" ? "#3b82f6" : "#374151",
                  color: "white",
                  border: "none",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontWeight: "600",
                  flex: 1
                }}
              >
                Back Side
              </button>
              <button 
                onClick={() => setSide("front")} 
                style={{ 
                  padding:"12px 20px", 
                  background: side === "front" ? "#3b82f6" : "#374151",
                  color: "white",
                  border: "none",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontWeight: "600",
                  flex: 1
                }}
              >
                Front Side
              </button>
            </div>
          </div>
          
          <div style={{ marginTop:"1.5rem", fontSize:"0.9rem", color:"#9ca3af", background: "#1f2937", padding: "12px", borderRadius: "6px" }}>
            <strong>Product:</strong> {(serial||"Unknown").slice(0,6).toUpperCase()} ({side})
          </div>
          
          {hasReferenceImage() && (
            <div style={{ marginTop:"1.5rem", background: "#065f46", padding: "16px", borderRadius: "8px" }}>
              <div style={{ fontSize:"0.9rem", marginBottom:"8px", color:"#10b981", fontWeight: "600" }}>
                🤖 AI Reference Available
              </div>
              
              {referenceImages[`${serial.trim().toUpperCase()}_${side}`]?.padPositions && (
                <div style={{ fontSize:"0.85rem", marginBottom:"12px", color:"#6ee7b7" }}>
                  📍 {referenceImages[`${serial.trim().toUpperCase()}_${side}`].padPositions.length} gap pads auto-detected
                </div>
              )}
              
              <div style={{ display: "flex", gap: "8px", flexDirection: "column" }}>
                <button 
                  onClick={() => {
                    const key = `${serial.trim().toUpperCase()}_${side}`;
                    if (referenceImages[key]) {
                      setValidationResult({
                        referenceImage: referenceImages[key].imageData,
                        timestamp: referenceImages[key].timestamp,
                        padPositions: referenceImages[key].padPositions || []
                      });
                      setShowOverlay(true);
                      setValidationStatus(null);
                    }
                  }}
                  style={{ background:"#047857", border:"none", padding:"8px 12px", borderRadius:"6px", fontSize:"0.85rem", color: "white", fontWeight: "600" }}
                >
                  👁️ Preview AI Detection
                </button>
                <button 
                  onClick={deleteReferenceImage}
                  style={{ background:"#dc2626", color:"white", border:"none", padding:"8px 12px", borderRadius:"6px", fontSize:"0.85rem", fontWeight: "600" }}
                >
                  🗑️ Delete Reference
                </button>
              </div>
            </div>
          )}
          
          <div style={{ marginTop:"2rem", fontSize:"0.85rem", color:"#9ca3af", background: "#1f2937", padding: "12px", borderRadius: "6px" }}>
            <div style={{ fontWeight: "600", marginBottom: "8px" }}>🤖 AI Library</div>
            <div>{Object.keys(referenceImages).length} AI-detected references stored</div>
            
            {Object.keys(referenceImages).length > 0 && (
              <button
                onClick={() => {
                  localStorage.removeItem('gapPadReferenceImages');
                  setReferenceImages({});
                  setMessage("All AI references cleared");
                }}
                style={{ background:"#dc2626", color:"white", border:"none", padding:"6px 10px", borderRadius:"4px", fontSize:"0.75rem", marginTop: "8px" }}
              >
                Clear All References
              </button>
            )}
          </div>
          
          <div style={{ marginTop:"1.5rem", fontSize:"0.8rem", color:"#6b7280", borderTop:"1px solid #374151", paddingTop:"1rem" }}>
            <div style={{ fontWeight: "600", marginBottom: "8px" }}>🧠 AI Detection Features:</div>
            <ul style={{ paddingLeft: "16px", lineHeight: "1.6" }}>
              <li>Automatic gap pad detection using computer vision</li>
              <li>HSV color space analysis for precise identification</li>
              <li>Size and aspect ratio filtering</li>
              <li>Real-time validation comparison</li>
              <li>Sub-pixel accuracy positioning</li>
            </ul>
          </div>
        </aside>
      </main>
    </div>
  );
}
