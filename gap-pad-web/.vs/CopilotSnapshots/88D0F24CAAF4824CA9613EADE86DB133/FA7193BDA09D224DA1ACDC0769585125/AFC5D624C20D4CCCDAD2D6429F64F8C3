import React, { useRef, useState, useEffect } from "react";

export default function App() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const detectionCanvasRef = useRef(null);
  const [serial, setSerial] = useState("");
  const [side, setSide] = useState("back");
  const [validationMode, setValidationMode] = useState(false);
  const [referenceImages, setReferenceImages] = useState({});
  const [captureMode, setCaptureMode] = useState(false);
  const [validationResult, setValidationResult] = useState(null);
  const [showOverlay, setShowOverlay] = useState(false);
  const [message, setMessage] = useState("");
  const [validationStatus, setValidationStatus] = useState(null);
  const [padPositions, setPadPositions] = useState([]);
  const [validationInProgress, setValidationInProgress] = useState(false);
  const validationIntervalRef = useRef(null);

  // Color detection parameters
  const colorThreshold = {
    // Magenta detection parameters (HSV color space)
    hueMin: 270,
    hueMax: 330,
    satMin: 50,
    valMin: 50
  };

  useEffect(() => {
    // Load saved reference images from localStorage on component mount
    const savedImages = localStorage.getItem('gapPadReferenceImages');
    if (savedImages) {
      try {
        const parsed = JSON.parse(savedImages);
        setReferenceImages(parsed);
      } catch (e) {
        console.error("Failed to parse saved images", e);
        setMessage("Error loading saved images");
      }
    }
  }, []);

  useEffect(() => {
    (async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }, 
          audio: false 
        });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          await videoRef.current.play();
        }
      } catch (err) {
        console.error("Camera error", err);
        setMessage("Camera access error. Please check permissions.");
      }
    })();

    // Cleanup function for validation interval
    return () => {
      if (validationIntervalRef.current) {
        clearInterval(validationIntervalRef.current);
      }
    };
  }, []);

  // Check if a color is within the magenta range
  const isMagenta = (r, g, b) => {
    // Convert RGB to HSV
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    
    let hue;
    if (delta === 0) {
      hue = 0;
    } else if (max === r) {
      hue = ((g - b) / delta) % 6;
    } else if (max === g) {
      hue = (b - r) / delta + 2;
    } else {
      hue = (r - g) / delta + 4;
    }
    
    hue = Math.round(hue * 60);
    if (hue < 0) hue += 360;
    
    const saturation = max === 0 ? 0 : Math.round((delta / max) * 100);
    const value = Math.round((max / 255) * 100);
    
    // Check if the color is in the magenta range
    return (
      (hue >= colorThreshold.hueMin && hue <= colorThreshold.hueMax) &&
      saturation >= colorThreshold.satMin && 
      value >= colorThreshold.valMin
    );
  };

  // Detect gap pads in an image
  const detectGapPads = (imageData) => {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    const img = new Image();
    img.onload = () => {
      tempCanvas.width = img.width;
      tempCanvas.height = img.height;
      tempCtx.drawImage(img, 0, 0);
      
      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      const data = imageData.data;
      
      // Array to store detected gap pad positions
      const positions = [];
      
      // Simplified detection algorithm - looks for clusters of magenta pixels
      const visited = new Set();
      const clusterMinSize = 100; // Minimum cluster size to be considered a gap pad
      
      for (let y = 0; y < tempCanvas.height; y += 4) { // Sampling every 4 pixels for performance
        for (let x = 0; x < tempCanvas.width; x += 4) {
          const index = (y * tempCanvas.width + x) * 4;
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          
          // If this pixel is magenta and not already part of a cluster
          if (isMagenta(r, g, b) && !visited.has(`${x},${y}`)) {
            // Use flood fill to find the cluster
            const cluster = floodFill(data, tempCanvas.width, tempCanvas.height, x, y, visited);
            
            if (cluster.points.length >= clusterMinSize) {
              // Calculate the center of the cluster
              const centerX = cluster.sumX / cluster.points.length;
              const centerY = cluster.sumY / cluster.points.length;
              
              positions.push({
                x: centerX / tempCanvas.width, // Store as ratio for resolution independence
                y: centerY / tempCanvas.height,
                size: cluster.points.length
              });
            }
          }
        }
      }
      
      setPadPositions(positions);
      
      // Draw detection results for visualization
      if (detectionCanvasRef.current) {
        const ctx = detectionCanvasRef.current.getContext('2d');
        detectionCanvasRef.current.width = tempCanvas.width;
        detectionCanvasRef.current.height = tempCanvas.height;
        
        // Draw original image
        ctx.drawImage(img, 0, 0);
        
        // Draw detected gap pad positions
        positions.forEach(pad => {
          ctx.beginPath();
          ctx.arc(
            pad.x * tempCanvas.width, 
            pad.y * tempCanvas.height, 
            10, 0, 2 * Math.PI
          );
          ctx.strokeStyle = 'lime';
          ctx.lineWidth = 3;
          ctx.stroke();
        });
      }
      
      return positions;
    };
    img.src = imageData;
  };

  // Simple flood fill algorithm to find connected magenta pixels
  const floodFill = (imageData, width, height, startX, startY, visited) => {
    const queue = [{x: startX, y: startY}];
    const result = {points: [], sumX: 0, sumY: 0};
    
    while (queue.length > 0) {
      const {x, y} = queue.shift();
      const key = `${x},${y}`;
      
      // Skip if already visited or out of bounds
      if (visited.has(key) || x < 0 || y < 0 || x >= width || y >= height) {
        continue;
      }
      
      // Check if pixel is magenta
      const index = (y * width + x) * 4;
      const r = imageData[index];
      const g = imageData[index + 1];
      const b = imageData[index + 2];
      
      if (!isMagenta(r, g, b)) {
        continue;
      }
      
      // Mark as visited
      visited.add(key);
      result.points.push({x, y});
      result.sumX += x;
      result.sumY += y;
      
      // Add neighbors to queue (4-connected)
      queue.push({x: x+4, y: y});
      queue.push({x: x-4, y: y});
      queue.push({x: x, y: y+4});
      queue.push({x: x, y: y-4});
    }
    
    return result;
  };

  const captureReferenceImage = () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }

    const video = videoRef.current;
    const canvas = canvasRef.current;
    
    if (!video || !canvas) return;
    
    const context = canvas.getContext('2d');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const imageData = canvas.toDataURL('image/jpeg');
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    // Detect gap pad positions
    setMessage("Analyzing gap pad positions...");
    
    // Processing happens in detectGapPads when the image loads
    const positions = detectGapPads(imageData);
    
    // Save the reference image and detected positions
    const updatedImages = {
      ...referenceImages,
      [key]: {
        imageData,
        timestamp: new Date().toISOString(),
        serial: serial.trim().toUpperCase(),
        side,
        padPositions: positions // Will be updated by the detectGapPads function
      }
    };
    
    setReferenceImages(updatedImages);
    localStorage.setItem('gapPadReferenceImages', JSON.stringify(updatedImages));
    setMessage(`Reference image saved for ${serial} (${side})`);
    setCaptureMode(false);
  };

  const validateCurrentView = () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }
    
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    if (!referenceImages[key]) {
      setMessage(`No reference image found for ${serial} (${side})`);
      return;
    }
    
    const refImage = referenceImages[key];
    
    setValidationResult({
      referenceImage: refImage.imageData,
      timestamp: refImage.timestamp,
      padPositions: refImage.padPositions || []
    });
    
    setShowOverlay(true);
    setMessage("Analyzing gap pad placement...");
    setValidationInProgress(true);
    
    // Start continuous validation
    if (validationIntervalRef.current) {
      clearInterval(validationIntervalRef.current);
    }
    
    validationIntervalRef.current = setInterval(() => {
      if (!videoRef.current || !canvasRef.current || !showOverlay) {
        return;
      }
      
      // Capture current frame
      const video = videoRef.current;
      const canvas = canvasRef.current;
      const context = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      context.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Get frame data for analysis
      const frameData = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = frameData.data;
      
      // Check reference positions for gap pads
      const referencePositions = refImage.padPositions || [];
      let matchedCount = 0;
      const tolerance = 0.05; // 5% tolerance for position matching
      
      // For each reference position, check if there's a gap pad in the current frame
      referencePositions.forEach(refPad => {
        // Calculate pixel coordinates based on ratio
        const checkX = Math.floor(refPad.x * canvas.width);
        const checkY = Math.floor(refPad.y * canvas.height);
        
        // Check a small area around the expected position
        const areaSize = Math.max(20, Math.floor(Math.sqrt(refPad.size) / 2));
        let foundMagenta = false;
        
        for (let dy = -areaSize; dy <= areaSize; dy += 4) {
          for (let dx = -areaSize; dx <= areaSize; dx += 4) {
            const x = checkX + dx;
            const y = checkY + dy;
            
            if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
              continue;
            }
            
            const index = (y * canvas.width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            
            if (isMagenta(r, g, b)) {
              foundMagenta = true;
              break;
            }
          }
          if (foundMagenta) break;
        }
        
        if (foundMagenta) {
          matchedCount++;
        }
      });
      
      // Calculate match percentage
      const matchPercentage = referencePositions.length > 0 
        ? (matchedCount / referencePositions.length) * 100 
        : 0;
      
      // Update validation status
      let status;
      if (matchPercentage >= 90) {
        status = "success";
      } else if (matchPercentage >= 70) {
        status = "warning";
      } else {
        status = "error";
      }
      
      setValidationStatus({
        status,
        matchPercentage,
        matchedCount,
        totalCount: referencePositions.length
      });
      
      // Update message
      if (status === "success") {
        setMessage(`Validation successful! ${matchedCount}/${referencePositions.length} gap pads detected.`);
      } else if (status === "warning") {
        setMessage(`Some gap pads may be misaligned (${matchedCount}/${referencePositions.length} detected).`);
      } else {
        setMessage(`Gap pad alignment incorrect (${matchedCount}/${referencePositions.length} detected).`);
      }
    }, 500); // Check every 500ms
  };

  const stopValidation = () => {
    if (validationIntervalRef.current) {
      clearInterval(validationIntervalRef.current);
    }
    setShowOverlay(false);
    setValidationInProgress(false);
    setValidationStatus(null);
  };

  const deleteReferenceImage = () => {
    if (!serial.trim()) {
      setMessage("Please enter a serial number first");
      return;
    }
    
    const key = `${serial.trim().toUpperCase()}_${side}`;
    
    if (!referenceImages[key]) {
      setMessage(`No reference image found for ${serial} (${side})`);
      return;
    }
    
    const updatedImages = { ...referenceImages };
    delete updatedImages[key];
    
    setReferenceImages(updatedImages);
    localStorage.setItem('gapPadReferenceImages', JSON.stringify(updatedImages));
    setMessage(`Reference image deleted for ${serial} (${side})`);
    
    if (validationResult) {
      stopValidation();
    }
  };

  const hasReferenceImage = () => {
    if (!serial.trim()) return false;
    const key = `${serial.trim().toUpperCase()}_${side}`;
    return !!referenceImages[key];
  };

  return (
    <div style={{ minHeight:"100vh", background:"#0a0a0a", color:"#e5e5e5", display:"flex", flexDirection:"column" }}>
      <header style={{ padding:"1rem", borderBottom:"1px solid #27272a" }}>
        <div>Gap Pad Web Validator</div>
      </header>

      <main style={{ flex:1, display:"grid", gridTemplateColumns:"2fr 1fr" }}>
        <section style={{ padding:"1rem" }}>
          <div style={{ position:"relative", background:"black", borderRadius:"12px", overflow:"hidden" }}>
            <video ref={videoRef} style={{ width:"100%", aspectRatio:"16/9", objectFit:"contain", display: showOverlay ? "none" : "block" }} playsInline autoPlay muted />
            
            {showOverlay && validationResult && (
              <div style={{ width:"100%", aspectRatio:"16/9", position:"relative" }}>
                <img 
                  src={validationResult.referenceImage} 
                  alt="Reference" 
                  style={{ width:"100%", height:"100%", objectFit:"contain", opacity:0.6 }} 
                />
                <video 
                  ref={videoRef} 
                  style={{ position:"absolute", top:0, left:0, width:"100%", height:"100%", objectFit:"contain", opacity:0.7, mixBlendMode:"difference" }} 
                  playsInline 
                  autoPlay 
                  muted 
                />
                
                {/* Draw pad position markers */}
                {validationResult.padPositions && validationResult.padPositions.map((pad, index) => (
                  <div
                    key={index}
                    style={{
                      position: "absolute",
                      left: `${pad.x * 100}%`,
                      top: `${pad.y * 100}%`,
                      width: "20px",
                      height: "20px",
                      borderRadius: "50%",
                      border: "2px solid lime",
                      transform: "translate(-50%, -50%)",
                      boxShadow: "0 0 0 2px rgba(0,0,0,0.5)"
                    }}
                  />
                ))}
                
                <div style={{ position:"absolute", bottom:"10px", left:"10px", background:"rgba(0,0,0,0.7)", padding:"8px", borderRadius:"4px", fontSize:"12px" }}>
                  Reference captured: {new Date(validationResult.timestamp).toLocaleString()}
                </div>
                
                {/* Validation status indicator */}
                {validationStatus && (
                  <div 
                    style={{ 
                      position:"absolute", 
                      top:"10px", 
                      left:"10px", 
                      background: validationStatus.status === "success" ? "rgba(22, 163, 74, 0.8)" : 
                                 validationStatus.status === "warning" ? "rgba(245, 158, 11, 0.8)" : 
                                 "rgba(225, 29, 72, 0.8)",
                      padding:"8px 12px", 
                      borderRadius:"4px",
                      fontSize: "14px",
                      fontWeight: "bold"
                    }}
                  >
                    {validationStatus.status === "success" ? "✓ PASS" : 
                     validationStatus.status === "warning" ? "⚠ CHECK" : "✗ FAIL"}
                     <div style={{ fontSize: "12px", fontWeight: "normal", marginTop: "4px" }}>
                       Match: {Math.round(validationStatus.matchPercentage)}%
                     </div>
                  </div>
                )}
                
                <button 
                  style={{ position:"absolute", top:"10px", right:"10px", background:"#e11d48", padding:"8px", borderRadius:"4px", border:"none", color:"white" }}
                  onClick={stopValidation}
                >
                  Exit Overlay
                </button>
              </div>
            )}
            
            <canvas ref={canvasRef} style={{ display: "none" }} />
            <canvas ref={detectionCanvasRef} style={{ display: "none" }} />
            
            {validationMode && !showOverlay && (
              <div style={{ position:"absolute", top:"10px", left:"10px", background:"rgba(0,0,0,0.6)", padding:"4px 8px", borderRadius:"8px" }}>
                Validation Mode Active
              </div>
            )}
            
            {captureMode && !showOverlay && (
              <div style={{ position:"absolute", top:"10px", left:"10px", background:"rgba(0,0,0,0.6)", padding:"4px 8px", borderRadius:"8px", color:"#f87171" }}>
                Capture Mode Active
              </div>
            )}
          </div>
          
          <div style={{ marginTop:"1rem", display:"flex", gap:"0.5rem", flexWrap:"wrap" }}>
            {validationMode ? (
              <>
                <button onClick={() => setValidationMode(false)}>
                  Exit Validation Mode
                </button>
                <button 
                  onClick={validateCurrentView} 
                  style={{ background: "#2563eb", color: "white", border: "none", padding: "8px 16px", borderRadius: "4px" }}
                  disabled={!hasReferenceImage()}
                >
                  Compare with Reference
                </button>
              </>
            ) : captureMode ? (
              <>
                <button onClick={() => setCaptureMode(false)}>
                  Cancel Capture
                </button>
                <button 
                  onClick={captureReferenceImage}
                  style={{ background: "#16a34a", color: "white", border: "none", padding: "8px 16px", borderRadius: "4px" }}
                >
                  Capture Reference Image
                </button>
              </>
            ) : (
              <>
                <button onClick={() => setValidationMode(true)}>
                  Enter Validation Mode
                </button>
                <button onClick={() => setCaptureMode(true)}>
                  Set Reference Image
                </button>
              </>
            )}
          </div>
          
          {message && (
            <div style={{ 
              marginTop:"0.75rem", 
              padding:"0.5rem", 
              background: message.includes("success") ? "rgba(22, 163, 74, 0.2)" : 
                        message.includes("incorrect") ? "rgba(225, 29, 72, 0.2)" : 
                        "rgba(0,0,0,0.4)", 
              borderRadius:"4px", 
              fontSize:"0.9rem" 
            }}>
              {message}
            </div>
          )}
        </section>

        <aside style={{ padding:"1rem", borderLeft:"1px solid #27272a" }}>
          <div>
            <label>Serial Number</label><br/>
            <input 
              value={serial} 
              onChange={e => setSerial(e.target.value)} 
              placeholder="Enter serial" 
              style={{ width:"100%", padding:"8px", marginTop:"4px", background:"#1f1f1f", border:"1px solid #3f3f3f", color:"#e5e5e5", borderRadius:"4px" }} 
            />
          </div>
          
          <div style={{ marginTop:"1rem" }}>
            <label>Gap Pad Side</label><br/>
            <div style={{ display:"flex", gap:"0.5rem", marginTop:"4px" }}>
              <button 
                onClick={() => setSide("back")} 
                style={{ 
                  padding:"8px 16px", 
                  background: side === "back" ? "#2563eb" : "#1f1f1f",
                  color: side === "back" ? "white" : "#e5e5e5",
                  border: "none",
                  borderRadius: "4px"
                }}
              >
                Back
              </button>
              <button 
                onClick={() => setSide("front")} 
                style={{ 
                  padding:"8px 16px", 
                  background: side === "front" ? "#2563eb" : "#1f1f1f",
                  color: side === "front" ? "white" : "#e5e5e5",
                  border: "none",
                  borderRadius: "4px"
                }}
              >
                Front
              </button>
            </div>
          </div>
          
          <div style={{ marginTop:"1rem", fontSize:"0.8rem", color:"#a1a1aa" }}>
            Product code: {(serial||"").slice(0,6).toUpperCase()} ({side})
          </div>
          
          {hasReferenceImage() && (
            <div style={{ marginTop:"1rem" }}>
              <div style={{ fontSize:"0.8rem", marginBottom:"0.5rem", color:"#34d399" }}>
                ✓ Reference image available
              </div>
              
              {/* Show detected pad count if available */}
              {referenceImages[`${serial.trim().toUpperCase()}_${side}`]?.padPositions && (
                <div style={{ fontSize:"0.8rem", marginBottom:"0.5rem", color:"#94a3b8" }}>
                  {referenceImages[`${serial.trim().toUpperCase()}_${side}`].padPositions.length} gap pads detected
                </div>
              )}
              
              <button 
                onClick={deleteReferenceImage}
                style={{ background:"#ef4444", color:"white", border:"none", padding:"4px 8px", borderRadius:"4px", fontSize:"0.8rem" }}
              >
                Delete Reference
              </button>
              <div style={{ marginTop:"0.5rem" }}>
                <button 
                  onClick={() => {
                    const key = `${serial.trim().toUpperCase()}_${side}`;
                    if (referenceImages[key]) {
                      setValidationResult({
                        referenceImage: referenceImages[key].imageData,
                        timestamp: referenceImages[key].timestamp,
                        padPositions: referenceImages[key].padPositions || []
                      });
                      setShowOverlay(true);
                      setValidationStatus(null); // No validation status when just viewing
                    }
                  }}
                  style={{ background:"#1f1f1f", border:"none", padding:"4px 8px", borderRadius:"4px", fontSize:"0.8rem" }}
                >
                  View Reference
                </button>
              </div>
            </div>
          )}
          
          <div style={{ marginTop:"1.5rem", fontSize:"0.8rem", color:"#a1a1aa", borderTop:"1px solid #27272a", paddingTop:"1rem" }}>
            <div>Reference Library:</div>
            <div style={{ fontSize:"0.7rem", marginTop:"0.5rem" }}>
              {Object.keys(referenceImages).length} images stored
            </div>
          </div>

          <div style={{ marginTop:"1.5rem", fontSize:"0.8rem", color:"#a1a1aa", borderTop:"1px solid #27272a", paddingTop:"1rem" }}>
            <div>Detection Settings:</div>
            <div style={{ fontSize:"0.7rem", marginTop:"0.5rem", lineHeight: "1.4" }}>
              Looking for magenta colored gap pads<br/>
              Tolerance: 5%<br/>
              Minimum size: 100px
            </div>
          </div>
        </aside>
      </main>
    </div>
  );
}
